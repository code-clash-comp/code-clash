<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Dashboard | Code Clash 2025</title>
  <link rel="stylesheet" href="styles.css">
  <link rel="stylesheet" href="dashboard.css">
  <link rel="icon" type="image/png" href="logo.png">
</head>
<body>
  <div class="page-container">
    <div class="nav" style="position:relative;">
      <div class="nav-name">
        <h1 class="nav-name-title">&lt;/&gt; Code Clash 2025</h1>
      </div>

      <div class="nav-actions">
        <button id="navAdmin" class="nav-actions-admin" style="display:none;">Admin Panel</button>
        <button id="navRegister" class="nav-actions-register">Home</button>
        <button id="navLogin" class="nav-actions-login">Logout</button>
      </div>

      <!-- Mobile hamburger -->
      <button id="mobileMenuBtn" class="hamburger" aria-label="Toggle menu" aria-expanded="false" aria-controls="mobileMenu">
        <span class="hamburger-box">
          <span class="hamburger-inner"></span>
        </span>
      </button>

      <!-- Mobile menu -->
      <div id="mobileMenu" class="mobile-menu" role="menu" aria-hidden="true">
        <div class="mobile-menu-inner"></div>
      </div>
    </div>

    <header class="dashboard-header container">
      <h2 class="page-title">Dashboard</h2>
      <div class="typing-line" style="margin-top:8px;">
        <span id="typingDashboard" class="typing-text"></span><span class="cursor" aria-hidden="true"></span>
      </div>
    </header>

    <main class="container" style="margin-top:18px;">
      <section class="panel profile-panel">
        <div class="panel-title">Your Profile</div>
        <div id="profileLoggedOut" class="small muted" style="margin-top:8px">Please <a href="login.html">login</a> to see and edit your profile.</div>

        <div id="profileCard" style="margin-top:10px; display:none">
          <div class="mini-grid">
            <div class="mini-card" id="card-name">
              <div class="mini-head">
                <div class="mini-title">Name</div>
                <button class="mini-edit" data-field="name" title="Edit name">‚úèÔ∏è</button>
              </div>
              <div class="mini-body">
                <div class="mini-value" id="val-name">-</div>
                <div class="mini-edit-area" id="edit-name" style="display:none">
                  <input id="inp-name-mini" type="text" placeholder="Full name" />
                  <div class="mini-actions">
                    <button class="btn mini-save" data-field="name">Save</button>
                    <button class="btn mini-cancel" data-field="name">Cancel</button>
                  </div>
                </div>
              </div>
            </div>

            <div class="mini-card" id="card-grade">
              <div class="mini-head">
                <div class="mini-title">Grade &amp; Section</div>
                <button class="mini-edit" data-field="grade" title="Edit grade/section">‚úèÔ∏è</button>
              </div>
              <div class="mini-body">
                <div class="mini-value" id="val-grade">-</div>
                <div class="mini-edit-area" id="edit-grade" style="display:none">
                  <input id="inp-grade-mini" type="text" placeholder="Grade & Section" />
                  <div class="mini-actions">
                    <button class="btn mini-save" data-field="grade">Save</button>
                    <button class="btn mini-cancel" data-field="grade">Cancel</button>
                  </div>
                </div>
              </div>
            </div>

            <div class="mini-card" id="card-phone">
              <div class="mini-head">
                <div class="mini-title">Phone</div>
                <button class="mini-edit" data-field="phone" title="Edit phone">‚úèÔ∏è</button>
              </div>
              <div class="mini-body">
                <div class="mini-value" id="val-phone">-</div>
                <div class="mini-edit-area" id="edit-phone" style="display:none">
                  <input id="inp-phone-mini" type="tel" placeholder="Phone number" />
                  <div class="mini-actions">
                    <button class="btn mini-save" data-field="phone">Save</button>
                    <button class="btn mini-cancel" data-field="phone">Cancel</button>
                  </div>
                </div>
              </div>
            </div>

            <div class="mini-card" id="card-email">
              <div class="mini-head">
                <div class="mini-title">Email</div>
                <button class="mini-edit" data-field="email" title="Edit email">‚úèÔ∏è</button>
              </div>
              <div class="mini-body">
                <div class="mini-value" id="val-email">-</div>
                <div class="mini-edit-area" id="edit-email" style="display:none">
                  <input id="inp-email-mini" type="email" placeholder="Email" />
                  <div class="mini-actions">
                    <button class="btn mini-save" data-field="email">Save</button>
                    <button class="btn mini-cancel" data-field="email">Cancel</button>
                  </div>
                </div>
              </div>
            </div>
          </div>

          <div id="teamBadgeWrap" style="margin-top:12px; display:none">
            <div class="small muted">Your team</div>
            <div id="teamBadge" class="team-badge" role="button" tabindex="0" title="Click to view your team"></div>
          </div>

          <div id="profileMsg" class="small muted" style="margin-top:10px; min-height:18px"></div>

          <!-- DELETE ACCOUNT BUTTON -->
          <div style="margin-top:12px;">
            <button id="deleteAccountBtn" class="btn destructive" title="Permanently delete your account and profile">Delete account</button>
          </div>
        </div>
      </section>

      <section class="panel teams-panel" style="margin-top:12px;">
        <div class="panel-title">Teams</div>
        <div class="small muted">Create or join a team. Max 8 teams total.</div>

        <div class="teams-controls" style="margin-top:12px; display:flex; gap:10px;">
          <button id="createTeamBtn" class="btn primary">Create Team</button>
          <button id="refreshBtn" class="btn">Refresh</button>
        </div>

        <div id="teamsList" class="teams-list" style="margin-top:12px"></div>
        <div id="teamNote" class="small muted" style="margin-top:10px"></div>
      </section>
    </main>

    <main class="container" style="margin-top:18px; margin-bottom:40px;">
      <section class="panel">
        <div class="panel-title">Competition Details</div>
        <div id="compDetails" class="small muted" style="margin-top:8px">
          <strong>Format:</strong> 1v1 duels, teams earn points.<br>
          <strong>Participants max:</strong> <span id="cMax">32</span><br>
          <strong>Teams max:</strong> 8<br>
          <strong>Team size limit:</strong> <span id="teamLimitDisplay">4</span><br>
          <strong>Rules:</strong> Be respectful. Follow time limits. No plagiarism.
        </div>
      </section>
    </main>

    <footer class="page-foot muted-no-margin">Hosted on GitHub Pages ¬∑ Good luck and have fun!</footer>

    <div id="createTeamModal" class="modal" aria-hidden="true">
      <div class="modal-panel">
        <h3 style="margin:0 0 8px 0;color:var(--accent)">Create a Team</h3>
        <label class="pf-label">Team name
          <input id="modalTeamName" type="text" placeholder="Short team name" />
        </label>
        <div style="margin-top:8px;">
          <div class="pf-label">Pick a team color</div>
          <div id="colorOptions" class="color-grid" style="margin-top:8px"></div>
        </div>

        <div style="display:flex; gap:8px; margin-top:12px;">
          <button id="modalCreateBtn" class="btn primary">Create</button>
          <button id="modalCancelBtn" class="btn">Cancel</button>
        </div>
        <div id="modalMsg" class="small muted" style="margin-top:8px; min-height:18px"></div>
      </div>
      <div class="modal-backdrop"></div>
    </div>

    <!-- Reauth password modal -->
    <div id="reauthModal" class="modal" aria-hidden="true">
      <div class="modal-panel">
        <h3 style="margin:0 0 8px 0;color:var(--accent)">Confirm deletion</h3>
        <div class="small muted">For security, please enter your password to confirm deletion of your account.</div>
        <label class="pf-label" style="margin-top:10px;">
          Password
          <input id="reauthPassword" type="password" placeholder="Your password" autocomplete="current-password" />
        </label>

        <div style="display:flex; gap:8px; margin-top:12px;">
          <button id="reauthConfirmBtn" class="btn destructive">Confirm delete</button>
          <button id="reauthCancelBtn" class="btn">Cancel</button>
        </div>
        <div id="reauthMsg" class="small muted" style="margin-top:8px; min-height:18px"></div>
      </div>
      <div class="modal-backdrop"></div>
    </div>

  </div>

<script>
(function(){
  const btn = document.getElementById('mobileMenuBtn');
  const menu = document.getElementById('mobileMenu');
  const inner = document.querySelector('.mobile-menu-inner');
  const desktopActions = document.querySelector('.nav-actions');

  if(!btn || !menu || !inner) return;

  const canonicalIds = ['navDashboard','navRegister','navLogin'];

  function setMobileVisibility(){
    const mobile = window.innerWidth <= 760;
    btn.style.display = mobile ? 'inline-flex' : 'none';
    menu.style.display = mobile ? '' : 'none';
    if(!mobile){
      menu.setAttribute('aria-hidden','true');
      btn.setAttribute('aria-expanded','false');
    } else {
      buildMobileMenu();
    }
  }
  setMobileVisibility();
  window.addEventListener('resize', setMobileVisibility);

  // returns true if element has inline style display:none or hidden attribute
  function explicitlyHidden(el){
    if(!el) return true;
    if(el.hidden) return true;
    const s = (el.getAttribute('style') || '').toLowerCase();
    if(/\bdisplay\s*:\s*none\b/.test(s)) return true;
    return false;
  }

  // include canonical items even if CSS media rules hide desktop nav on mobile
  function shouldInclude(el){
    if(!el) return false;
    // explicit inline hiding => definitely exclude
    if(explicitlyHidden(el)) return false;
    // if it has attribute data-force-mobile="true" include
    if(el.getAttribute && el.getAttribute('data-force-mobile') === 'true') return true;
    // otherwise include by default (we want menu usable for unauthed users)
    return true;
  }

  // canonical action fallback (guaranteed navigation even if desktop handlers absent)
  function performCanonicalActionById(id){
    switch(id){
      case 'navRegister':
        window.location.href = 'register.html';
        return;
      case 'navLogin':
        window.location.href = 'login.html';
        return;
      case 'navDashboard':
        // prefer dashboard; if admin link is visible on desktop it will be shown separately
        window.location.href = 'dashboard.html';
        return;
      default:
        return;
    }
  }

  function proxyClickToOriginal(orig, menuBtn){
    // hide menu first
    menu.setAttribute('aria-hidden','true');
    btn.setAttribute('aria-expanded','false');

    // if original element has a direct onclick function, call it
    try {
      if(orig && typeof orig.onclick === 'function'){
        orig.onclick();
        return;
      }
      // if original has a data-action attribute, trust it (not common, but helpful)
      const dataAction = orig && orig.getAttribute && orig.getAttribute('data-action');
      if(dataAction){
        // common patterns: "logout", "open-dashboard" etc.
        if(dataAction === 'logout'){
          // try to trigger click (some pages attach handler to element)
          try { orig.click(); } catch(e){ /* ignore */ }
          return;
        }
      }
      // otherwise perform canonical fallback if available
      if(orig && orig.id && canonicalIds.includes(orig.id)){
        performCanonicalActionById(orig.id);
        return;
      }
      // last resort: call click() on the original to fire listeners attached via addEventListener
      if(orig && typeof orig.click === 'function'){
        orig.click();
        return;
      }
    } catch(err){
      console.error('Mobile menu proxy click failed', err);
    }
    // absolute fallback: do nothing (shouldn't happen)
  }

  function buildMobileMenu(){
    inner.innerHTML = '';

    // canonical items first (deterministic order)
    for(const id of canonicalIds){
      const orig = document.getElementById(id);
      // include if element exists AND not explicitly hidden
      if(!orig) continue;
      if(!shouldInclude(orig)) continue;

      const b = document.createElement('button');
      b.className = orig.className || '';
      b.textContent = (orig.getAttribute('aria-label') || orig.innerText || orig.textContent || id).trim();
      b.dataset.origId = id;
      b.addEventListener('click', (e) => proxyClickToOriginal(orig, b));
      inner.appendChild(b);
    }

    // then include any other visible buttons from .nav-actions (avoid duplicating canonical items)
    if(desktopActions){
      Array.from(desktopActions.children).forEach(orig => {
        if(!orig) return;
        if(orig.id && canonicalIds.includes(orig.id)) return;
        if(!shouldInclude(orig)) return;

        const b = document.createElement('button');
        b.className = orig.className || '';
        b.textContent = (orig.getAttribute('aria-label') || orig.innerText || orig.textContent || 'Action').trim();
        if(orig.id) b.dataset.origId = orig.id;
        b.addEventListener('click', (e) => proxyClickToOriginal(orig, b));
        inner.appendChild(b);
      });
    }

    if(inner.children.length === 0){
      const fallback = document.createElement('div');
      fallback.className = 'small-muted';
      fallback.textContent = 'No actions available';
      inner.appendChild(fallback);
    }
  }

  function openMenu(){
    buildMobileMenu();
    menu.setAttribute('aria-hidden','false');
    btn.setAttribute('aria-expanded','true');
    setTimeout(()=> document.addEventListener('click', outsideClick), 10);
    document.addEventListener('keydown', onKeyDown);
  }
  function closeMenu(){
    menu.setAttribute('aria-hidden','true');
    btn.setAttribute('aria-expanded','false');
    document.removeEventListener('click', outsideClick);
    document.removeEventListener('keydown', onKeyDown);
  }
  function outsideClick(e){
    if(menu.contains(e.target) || btn.contains(e.target)) return;
    closeMenu();
  }
  function onKeyDown(e){
    if(e.key === 'Escape') closeMenu();
  }

  btn.addEventListener('click', (ev)=>{
    ev.stopPropagation();
    const expanded = btn.getAttribute('aria-expanded') === 'true';
    if(expanded) closeMenu(); else openMenu();
  });

  // rebuild menu when desktopActions change
  const observer = new MutationObserver((mutations) => {
    if(window._menuRebuildTimer) clearTimeout(window._menuRebuildTimer);
    window._menuRebuildTimer = setTimeout(() => {
      if(window.innerWidth <= 760) buildMobileMenu();
    }, 60);
  });
  if(desktopActions) observer.observe(desktopActions, { childList: true, subtree: true, attributes: true, attributeFilter: ['style','class','hidden'] });

  // also listen for explicit nav-updated event
  document.addEventListener('nav-updated', () => {
    if(window.innerWidth <= 760) buildMobileMenu();
  });

  // initial build for mobile
  if(window.innerWidth <= 760) buildMobileMenu();

})();
</script>

<script type="module">
(async function(){
  const FIREBASE_CONFIG = {
    apiKey: "AIzaSyDpKPIqiWrGpvE3xL6TBRQEEfrpZGIfedM",
    authDomain: "code-clash-2025.firebaseapp.com",
    projectId: "code-clash-2025",
    storageBucket: "code-clash-2025.appspot.com",
    messagingSenderId: "13717806434",
    appId: "1:13717806434:web:8aa7799e7f87ebbdf0603b",
    measurementId: "G-0BMTHMYMEL"
  };
  const MAX_TEAMS = 8;
  const MAX_PARTICIPANTS = 32;
  const TEAM_SIZE_LIMIT = 4;
  const TEAM_COLORS = [
    { id: 'green',  hex: '#7fbf7f', name:'Green' },
    { id: 'teal',   hex: '#5fb0a0', name:'Teal' },
    { id: 'blue',   hex: '#6ea8ff', name:'Blue' },
    { id: 'purple', hex: '#b58cff', name:'Purple' },
    { id: 'orange', hex: '#f0a76b', name:'Orange' },
    { id: 'red',    hex: '#ff7b7b', name:'Red' },
    { id: 'yellow', hex: '#ffe08a', name:'Yellow' },
    { id: 'pink',   hex: '#ffb3d1', name:'Pink' }
  ];
  document.getElementById('teamLimitDisplay').textContent = String(TEAM_SIZE_LIMIT);
  const phrases = [
    'Are you ready to duel?',
    'Fastest correct solution wins.',
    '1v1 duels ‚Äî team points on the line.',
    'Sharpen your loops. Debug your logic.'
  ];

  (function typingHeader(){
    const el = document.getElementById('typingDashboard');
    if(!el) return;
    let p=0,ch=0,deleting=false;
    const typingSpeed = 45, pauseAfter = 900;
    function tick(){
      const cur = phrases[p] || '';
      if(!deleting){
        ch = Math.min(ch+1, cur.length);
        el.textContent = cur.slice(0,ch);
        if(ch === cur.length){ deleting = true; setTimeout(tick, pauseAfter); return; }
      } else {
        ch = Math.max(ch-1, 0);
        el.textContent = cur.slice(0,ch);
        if(ch === 0){ deleting = false; p=(p+1)%phrases.length; }
      }
      setTimeout(tick, deleting ? Math.round(typingSpeed/1.2) : typingSpeed);
    }
    tick();
  })();

  // DOM refs + nav fix
  const navRegister = document.getElementById('navRegister');
  const navLogin = document.getElementById('navLogin');
  const navAdmin = document.getElementById('navAdmin'); // admin quick link
  navRegister.onclick = ()=> { window.location.href = '/code-clash/'; };

  const valName = document.getElementById('val-name');
  const valGrade = document.getElementById('val-grade');
  const valPhone = document.getElementById('val-phone');
  const valEmail = document.getElementById('val-email');

  const editButtons = Array.from(document.querySelectorAll('.mini-edit'));
  const saveButtons = Array.from(document.querySelectorAll('.mini-save'));
  const cancelButtons = Array.from(document.querySelectorAll('.mini-cancel'));

  const inpName = document.getElementById('inp-name-mini');
  const inpGrade = document.getElementById('inp-grade-mini');
  const inpPhone = document.getElementById('inp-phone-mini');
  const inpEmail = document.getElementById('inp-email-mini');

  const teamsList = document.getElementById('teamsList');
  const teamNote = document.getElementById('teamNote');
  const createTeamBtn = document.getElementById('createTeamBtn');
  const refreshBtn = document.getElementById('refreshBtn');
  const cMax = document.getElementById('cMax'); cMax.textContent = String(MAX_PARTICIPANTS);

  const teamBadgeWrap = document.getElementById('teamBadgeWrap');
  const teamBadge = document.getElementById('teamBadge');

  const profileLoggedOut = document.getElementById('profileLoggedOut');
  const profileCard = document.getElementById('profileCard');
  const profileMsg = document.getElementById('profileMsg');
  const deleteAccountBtn = document.getElementById('deleteAccountBtn');

  const createTeamModal = document.getElementById('createTeamModal');
  const modalTeamName = document.getElementById('modalTeamName');
  const colorOptions = document.getElementById('colorOptions');
  const modalCreateBtn = document.getElementById('modalCreateBtn');
  const modalCancelBtn = document.getElementById('modalCancelBtn');
  const modalMsg = document.getElementById('modalMsg');

  const teamsPanel = document.querySelector('.teams-panel'); // used to toggle disabled-block for admins

  const [
    { initializeApp },
    { getFirestore, collection, doc, updateDoc, addDoc, onSnapshot, arrayUnion, arrayRemove, deleteDoc, runTransaction, getDoc },
    { getAuth, onAuthStateChanged, updateProfile, updateEmail, signOut, deleteUser, reauthenticateWithCredential, EmailAuthProvider }
  ] = await Promise.all([
    import('https://www.gstatic.com/firebasejs/9.22.2/firebase-app.js'),
    import('https://www.gstatic.com/firebasejs/9.22.2/firebase-firestore.js'),
    import('https://www.gstatic.com/firebasejs/9.22.2/firebase-auth.js')
  ]).catch(err=>{ console.error('firebase imports failed', err); throw err; });

  const app = initializeApp(FIREBASE_CONFIG);
  const db = getFirestore(app);
  const auth = getAuth(app);

  let currentUser = null;
  let currentUserDoc = null;
  let allTeams = [];
  let usersMap = {};

  // admin flag (true if user is admin/superadmin)
  let currentUserIsAdmin = false;

  // utility: apply admin UI changes (greying out, note, disabling create)
  function applyAdminUI(){
    // toggle teams panel disabled appearance
    if(teamsPanel){
      if(currentUserIsAdmin){
        teamsPanel.classList.add('disabled-block');
      } else {
        teamsPanel.classList.remove('disabled-block');
      }
    }

    // ensure createTeamBtn disabled when admin
    if(createTeamBtn){
      if(currentUserIsAdmin){
        createTeamBtn.classList.add('disabled-btn');
        createTeamBtn.disabled = true;
      } else {
        createTeamBtn.classList.remove('disabled-btn');
        createTeamBtn.disabled = false;
      }
    }

    // Insert or remove admin note below teams-controls
    const controls = document.querySelector('.teams-controls');
    if(controls){
      let note = document.getElementById('adminTeamsNote');
      if(currentUserIsAdmin){
        if(!note){
          note = document.createElement('div');
          note.id = 'adminTeamsNote';
          note.className = 'admin-disabled-note small muted';
          note.textContent = 'You are an admin ‚Äî you cannot join or manage teams as a participant.';
          controls.insertAdjacentElement('afterend', note);
        }
      } else {
        if(note) note.remove();
      }
    }

    // re-render teams list so buttons reflect admin mode
    renderTeamsList();
  }

  onSnapshot(collection(db, 'users'), (snap)=>{
    usersMap = {};
    snap.forEach(d=> usersMap[d.id] = d.data());
    populateMiniValues();
    renderTeamsList();
    updateTeamBadge();
  }, err=>{ console.error('users listener', err); });

  function showLoggedOut(){ profileLoggedOut.style.display='block'; profileCard.style.display='none'; teamBadgeWrap.style.display='none'; }
  function showProfileCard(){ profileLoggedOut.style.display='none'; profileCard.style.display='block'; }

  function populateMiniValues(){
    const uid = currentUser?.uid;
    const fallback = usersMap[uid] || {};
    valName.textContent = (currentUserDoc?.name) || fallback.name || (currentUser?.displayName) || '-';
    valGrade.textContent = currentUserDoc?.grade || fallback.grade || '-';
    valPhone.textContent = currentUserDoc?.phone || fallback.phone || '-';
    valEmail.textContent = currentUser?.email || currentUserDoc?.email || fallback.email || '-';
  }

  // helper to show all values / hide edit areas (fixes the blanking bug)
  function showAllMiniValues(){
    document.querySelectorAll('.mini-value').forEach(el=> el.style.display = 'block');
    document.querySelectorAll('.mini-edit-area').forEach(el=> el.style.display = 'none');
  }

  function openEdit(field){
    // hide everything, then show only the requested edit area
    document.querySelectorAll('.mini-value').forEach(el=>el.style.display='none');
    document.querySelectorAll('.mini-edit-area').forEach(el=>el.style.display='none');
    const editArea = document.getElementById('edit-' + field);
    const valEl = document.getElementById('val-' + field);
    if(!editArea || !valEl) return;
    if(field === 'name') inpName.value = currentUserDoc?.name || usersMap[currentUser?.uid]?.name || currentUser?.displayName || '';
    if(field === 'grade') inpGrade.value = currentUserDoc?.grade || usersMap[currentUser?.uid]?.grade || '';
    if(field === 'phone') inpPhone.value = currentUserDoc?.phone || usersMap[currentUser?.uid]?.phone || '';
    if(field === 'email') inpEmail.value = currentUser?.email || currentUserDoc?.email || usersMap[currentUser?.uid]?.email || '';
    valEl.style.display='none';
    editArea.style.display='block';
    const input = editArea.querySelector('input'); if(input) input.focus();
  }

  function closeEdit(field){
    // ensure ALL fields are restored (this fixes the bug)
    showAllMiniValues();
    profileMsg.textContent = '';
  }

  async function saveField(field){
    if(!currentUser) { alert('Please login to edit'); return; }
    profileMsg.textContent = '';
    let newVal = '';
    if(field === 'name') newVal = inpName.value.trim();
    if(field === 'grade') newVal = inpGrade.value.trim();
    if(field === 'phone') newVal = inpPhone.value.trim();
    if(field === 'email') newVal = inpEmail.value.trim();

    if(field === 'name' && !newVal){
      profileMsg.style.color = '#f6a6a6'; profileMsg.textContent = 'Name cannot be empty.'; return;
    }

    const saveBtn = document.querySelector(`.mini-save[data-field="${field}"]`);
    if(saveBtn){ saveBtn.disabled = true; saveBtn.textContent = 'Saving...'; }

    try {
      const userRef = doc(db, 'users', currentUser.uid);
      const patch = {}; patch[field] = newVal || '';
      await updateDoc(userRef, patch);

      // optimistic local update so other fields don't "blink" while waiting for snapshot
      if(!currentUserDoc) currentUserDoc = {};
      currentUserDoc[field] = newVal || '';
      // if name changed, update auth displayName when possible
      if(field === 'name' && currentUser.displayName !== newVal){
        try { await updateProfile(currentUser, { displayName: newVal }); } catch(e){ console.warn('updateProfile failed', e); }
      }
      // email update may require recent login; we attempted but show friendly message if it fails
      if(field === 'email' && newVal && newVal !== (currentUser.email || currentUserDoc?.email || '')){
        try {
          await updateEmail(currentUser, newVal);
        } catch(e){
          console.warn('updateEmail failed', e);
          profileMsg.style.color = '#f6a6a6';
          profileMsg.textContent = 'Email not updated in Auth: recent login required. Profile doc updated.';
        }
      } else {
        profileMsg.style.color = '#bfe8c6';
        profileMsg.textContent = 'Saved.';
      }

      // update visible values immediately
      populateMiniValues();

    } catch(e){
      console.error('save field err', e);
      profileMsg.style.color = '#f6a6a6';
      profileMsg.textContent = 'Failed to save. Try again.';
    } finally {
      if(saveBtn){ saveBtn.disabled = false; saveBtn.textContent = 'Save'; }
      closeEdit(field);
    }
  }

  editButtons.forEach(btn => btn.onclick = ()=> openEdit(btn.dataset.field));
  saveButtons.forEach(btn => btn.onclick = ()=> saveField(btn.dataset.field));
  cancelButtons.forEach(btn => btn.onclick = ()=> closeEdit(btn.dataset.field));

  onSnapshot(collection(db, 'teams'), (snap)=>{
    allTeams = [];
    snap.forEach(d=> allTeams.push({ id:d.id, ...d.data() }));
    renderTeamsList();
    updateCreateButtonState();
    updateTeamBadge();
    renderColorOptions();
  }, err=>{ console.error('teams listener', err); });

  function renderTeamsList(){
    teamsList.innerHTML = '';
    if(allTeams.length === 0){
      const el = document.createElement('div'); el.className='small muted'; el.textContent='No teams yet. Create one!';
      teamsList.appendChild(el); return;
    }
    allTeams.sort((a,b)=> {
      if(a.createdAt && b.createdAt) return (a.createdAt.seconds||0) - (b.createdAt.seconds||0);
      return (a.name||'').localeCompare(b.name||'');
    });

    allTeams.forEach(team=>{
      const d = document.createElement('details');
      d.className = 'team-card-details';
      const summary = document.createElement('summary'); summary.className = 'team-card';
      const colorBar = document.createElement('div');
      colorBar.className = 'team-color-bar';
      colorBar.style.background = team.color || '#7fbf7f';
      summary.appendChild(colorBar);

      const hdr = document.createElement('div'); hdr.className = 'team-card-hdr';
      const name = document.createElement('div'); name.className='team-card-name'; name.textContent = team.name || 'Unnamed Team';
      const meta = document.createElement('div'); meta.className='small muted'; meta.textContent = `${(team.members||[]).length} member${(team.members||[]).length===1?'':'s'}`;
      hdr.appendChild(name); hdr.appendChild(meta);
      summary.appendChild(hdr);

      const actions = document.createElement('div'); actions.style.display='flex'; actions.style.gap='8px'; actions.style.alignItems='center';
      const isCaptain = currentUser && team.captainUid === currentUser.uid;
      if(team.captainUid){
        const cap = document.createElement('span'); cap.className='crown'; cap.textContent='üëë'; cap.title='Captain';
        actions.appendChild(cap);
      }

      const viewBtn = document.createElement('button'); viewBtn.className='btn'; viewBtn.textContent='Open';
      viewBtn.onclick = (e)=> { e.preventDefault(); d.open = !d.open; };
      actions.appendChild(viewBtn);

      // membership controls - create buttons but guard behavior for admin users
      const isMember = currentUser && (team.members||[]).includes(currentUser.uid);
      const userTeam = currentUser && allTeams.find(t => (t.members||[]).includes(currentUser.uid));
      const joinBtn = document.createElement('button'); joinBtn.className='btn'; joinBtn.textContent='Join';
      const leaveBtn = document.createElement('button'); leaveBtn.className='btn'; leaveBtn.textContent='Leave';

      if(isMember) joinBtn.style.display='none'; else joinBtn.style.display='inline-block';
      if(!isMember) leaveBtn.style.display='none';

      // If admin, mark them disabled and add tooltip
      if(currentUserIsAdmin){
        joinBtn.disabled = true;
        joinBtn.classList.add('disabled-btn');
        joinBtn.title = 'Admins cannot join teams';
        leaveBtn.disabled = true;
        leaveBtn.classList.add('disabled-btn');
        leaveBtn.title = 'Admins cannot leave teams';
      } else {
        // non-admin hooks preserved
        if((team.members||[]).length >= TEAM_SIZE_LIMIT) { joinBtn.disabled = true; joinBtn.classList.add('disabled-btn'); joinBtn.title='Team is full'; }
        if(userTeam && !isMember){ joinBtn.disabled = true; joinBtn.classList.add('disabled-btn'); joinBtn.title='You are in another team'; }
      }

      joinBtn.onclick = async (ev)=> {
        ev.preventDefault();
        if(currentUserIsAdmin){ alert('Admins cannot join teams.'); return; }
        if(!currentUser){ alert('Login to join'); return; }
        const alreadyInThis = (team.members||[]).includes(currentUser.uid);
        if(alreadyInThis) { alert('You are already in this team.'); return; }

        const oldTeam = allTeams.find(t => (t.members||[]).includes(currentUser.uid));
        if(!oldTeam){
          if((team.members||[]).length >= TEAM_SIZE_LIMIT){ alert('Team is full.'); return; }
          try{
            await updateDoc(doc(db,'teams',team.id), { members: arrayUnion(currentUser.uid) });
          } catch(e){ console.error('join err', e); alert('Failed to join (permissions?).'); }
          return;
        }

        if(oldTeam.id === team.id){ alert('You are already in this team.'); return; }
        if(team.members && team.members.length >= TEAM_SIZE_LIMIT){ alert('Team is full.'); return; }
        if(!confirm(`You are currently in "${oldTeam.name}". Move to "${team.name}"?`)) return;

        try{
          await runTransaction(db, async (tx)=>{
            const newRef = doc(db,'teams',team.id);
            const oldRef = doc(db,'teams',oldTeam.id);
            const newSnap = await tx.get(newRef);
            const oldSnap = await tx.get(oldRef);
            if(!newSnap.exists()) throw new Error('Target team disappeared');
            if(!oldSnap.exists()) throw new Error('Source team disappeared');

            const newMembers = (newSnap.data().members || []);
            const oldMembers = (oldSnap.data().members || []);
            if(newMembers.includes(currentUser.uid)) throw new Error('Already in target');
            if(oldSnap.data().captainUid === currentUser.uid) throw new Error('Transfer captain before leaving the old team.');
            if(newMembers.length >= TEAM_SIZE_LIMIT) throw new Error('Target team full');

            tx.update(oldRef, { members: oldMembers.filter(u=> u !== currentUser.uid) });
            tx.update(newRef, { members: arrayUnion(currentUser.uid) });
          });
        } catch(e){
          console.error('switch team transaction failed', e);
          alert(e?.message || 'Failed to switch teams (permissions or conflict).');
        }
      };

      leaveBtn.onclick = async (ev)=> {
        ev.preventDefault();
        if(currentUserIsAdmin){ alert('Admins cannot leave teams.'); return; }
        if(!currentUser){ alert('Login to leave'); return; }
        if(team.captainUid === currentUser.uid){ alert("You're the captain ‚Äî transfer or disband to leave."); return; }
        try{ await updateDoc(doc(db,'teams',team.id), { members: arrayRemove(currentUser.uid) }); } catch(e){ console.error('leave err', e); alert('Failed to leave (permissions?).'); }
      };

      // Append membership buttons
      actions.appendChild(joinBtn);
      actions.appendChild(leaveBtn);

      // Disband / captain actions only shown to non-admins (admins can't manage teams here)
      if(!currentUserIsAdmin && isCaptain){
        const dis = document.createElement('button'); dis.className='btn'; dis.textContent='Disband';
        dis.onclick = async (ev)=>{ ev.preventDefault(); if(!confirm(`Disband "${team.name}"?`)) return; try{ await deleteDoc(doc(db,'teams',team.id)); } catch(e){ console.error(e); alert('Failed to disband (permissions?).'); } };
        actions.appendChild(dis);
      } else if (currentUserIsAdmin && isCaptain) {
        // If somehow captain but admin, show muted label instead of actions
        const admLabel = document.createElement('div'); admLabel.className='small muted'; admLabel.textContent='(Admin: cannot manage here)';
        actions.appendChild(admLabel);
      }

      summary.appendChild(actions);
      d.appendChild(summary);

      const body = document.createElement('div'); body.className='team-expanded';
      body.style.padding = '10px';

      const membersWrap = document.createElement('div');
      (team.members||[]).forEach(uid=>{
        const row = document.createElement('div'); row.className='team-member-row';
        row.style.display='flex'; row.style.justifyContent='space-between'; row.style.alignItems='center'; row.style.padding='6px 0';

        const profile = usersMap[uid] || null;
        const displayName = profile?.name || profile?.email || uid;
        const left = document.createElement('div');
        left.innerHTML = `${displayName} ${uid === team.captainUid ? '<span class="small muted">(captain)</span>' : ''} ${uid === currentUser?.uid ? '<span class="small muted">(you)</span>' : ''}`;

        const right = document.createElement('div'); right.style.display='flex'; right.style.gap='8px';
        if(!currentUserIsAdmin && currentUser && team.captainUid === currentUser.uid && uid !== currentUser.uid){
          const rm = document.createElement('button'); rm.className='btn small-btn'; rm.textContent='Remove';
          rm.onclick = async ()=>{ if(!confirm(`Remove ${displayName}?`)) return; try{ await updateDoc(doc(db,'teams',team.id), { members: arrayRemove(uid) }); } catch(e){ console.error(e); alert('Failed to remove'); } };
          const promote = document.createElement('button'); promote.className='btn small-btn'; promote.textContent='Make Captain';
          promote.onclick = async ()=>{ if(!confirm(`Make ${displayName} the captain?`)) return; try{ await updateDoc(doc(db,'teams',team.id), { captainUid: uid, ownerUid: uid }); } catch(e){ console.error(e); alert('Failed to transfer captain'); } };
          right.appendChild(promote); right.appendChild(rm);
        } else if (currentUserIsAdmin && currentUser && team.captainUid === currentUser.uid && uid !== currentUser.uid){
          // admin: show muted note
          const muted = document.createElement('div'); muted.className = 'small muted'; muted.textContent = '(admin ‚Äî no actions)';
          right.appendChild(muted);
        }

        if(!currentUserIsAdmin && currentUser && uid === currentUser.uid && team.captainUid !== currentUser.uid){
          const leaveSmall = document.createElement('button'); leaveSmall.className='btn small-btn'; leaveSmall.textContent='Leave';
          leaveSmall.onclick = async ()=>{ if(!confirm('Leave this team?')) return; try{ await updateDoc(doc(db,'teams',team.id), { members: arrayRemove(currentUser.uid) }); } catch(e){ console.error(e); alert('Failed to leave'); } };
          right.appendChild(leaveSmall);
        } else if (currentUserIsAdmin && currentUser && uid === currentUser.uid) {
          const muted = document.createElement('div'); muted.className='small muted'; muted.textContent='(admin)';
          right.appendChild(muted);
        }

        row.appendChild(left); row.appendChild(right); membersWrap.appendChild(row);
      });
      body.appendChild(membersWrap);
      d.appendChild(body);
      teamsList.appendChild(d);
    });
  }

  function updateCreateButtonState(){
    const userHasTeam = currentUser && allTeams.some(t => (t.members||[]).includes(currentUser.uid));
    if(allTeams.length >= MAX_TEAMS || userHasTeam){
      createTeamBtn.classList.add('disabled-btn'); createTeamBtn.disabled = true;
      teamNote.textContent = allTeams.length >= MAX_TEAMS ? 'Team cap reached (8).' : 'You already belong to a team.';
    } else {
      // respect admin state
      if(!currentUserIsAdmin){
        createTeamBtn.classList.remove('disabled-btn'); createTeamBtn.disabled = false;
      } else {
        createTeamBtn.classList.add('disabled-btn'); createTeamBtn.disabled = true;
      }
      teamNote.textContent = '';
    }
  }

  function updateTeamBadge(){
    if(!currentUser || !currentUser.uid){ teamBadgeWrap.style.display='none'; return; }
    const myTeam = allTeams.find(t => (t.members||[]).includes(currentUser.uid));
    if(!myTeam){ teamBadgeWrap.style.display='none'; return; }
    teamBadgeWrap.style.display='block';
    teamBadge.textContent = `${myTeam.name} (${(myTeam.members||[]).length})`;
    teamBadge.style.borderColor = 'rgba(143,217,155,0.06)';
    teamBadge.onclick = ()=> {
      const detailsEls = Array.from(document.querySelectorAll('.team-card-details'));
      for(const d of detailsEls){
        const nameEl = d.querySelector('.team-card-name');
        if(nameEl && nameEl.textContent === myTeam.name){
          d.open = true;
          d.scrollIntoView({ behavior:'smooth', block:'center' });
          return;
        }
      }
    };
  }

  // replace existing renderColorOptions() with this
function renderColorOptions(){
  colorOptions.innerHTML = '';
  const used = new Set((allTeams || []).map(t => (t.color || '').toLowerCase()).filter(Boolean));

  TEAM_COLORS.forEach((c, i)=>{
    const btn = document.createElement('button');
    btn.className = 'color-option';
    btn.type = 'button';
    btn.dataset.color = c.hex;
    btn.title = c.name;
    btn.setAttribute('aria-label', c.name);

    // style
    btn.style.background = c.hex;
    btn.style.position = 'relative';

    // If color used, grey it out and mark disabled
    if(used.has(c.hex.toLowerCase())){
      btn.disabled = true;
      btn.setAttribute('aria-disabled', 'true');
      btn.title = `${c.name} ‚Äî already used`;
      btn.classList.remove('selected');
      // add a subtle checkmark overlay to indicate "used"
      const overlay = document.createElement('span');
      overlay.className = 'color-used-badge';
      overlay.textContent = 'Used';
      btn.appendChild(overlay);
    } else {
      btn.onclick = (e)=> {
        e.preventDefault();
        document.querySelectorAll('.color-option').forEach(b=> b.classList.remove('selected'));
        btn.classList.add('selected');
      };
    }

    colorOptions.appendChild(btn);
  });

  // auto-select first available (non-disabled) color
  const first = colorOptions.querySelector('.color-option:not([disabled])');
  document.querySelectorAll('.color-option').forEach(b=> b.classList.remove('selected'));
  if(first) first.classList.add('selected');
}


  function openModal(){
    if(currentUserIsAdmin){
      modalMsg.style.color = '#f6a6a6';
      modalMsg.textContent = 'Admins cannot create teams.';
      return;
    }
    renderColorOptions(); createTeamModal.setAttribute('aria-hidden','false'); createTeamModal.classList.add('open'); modalMsg.textContent = ''; modalTeamName.value='';
  }
  function closeModal(){ createTeamModal.setAttribute('aria-hidden','true'); createTeamModal.classList.remove('open'); modalMsg.textContent = ''; }

  createTeamBtn.onclick = ()=> openModal();
  modalCancelBtn.onclick = ()=> closeModal();

  modalCreateBtn.onclick = async ()=>{
    if(currentUserIsAdmin){ modalMsg.style.color = '#f6a6a6'; modalMsg.textContent = 'Admins cannot create teams.'; return; }
    if(!currentUser){ alert('Login to create team'); return; }
    const name = (modalTeamName.value || '').trim();
    if(!name){ modalMsg.style.color='#f6a6a6'; modalMsg.textContent = 'Please enter a team name.'; return; }
    const sel = document.querySelector('.color-option.selected');
    const color = sel ? sel.dataset.color : TEAM_COLORS[0].hex;
    if(allTeams.some(t => (t.color || '').toLowerCase() === (color||'').toLowerCase())){
      modalMsg.style.color = '#f6a6a6'; modalMsg.textContent = 'That color is already used. Pick another.'; renderColorOptions(); return;
    }
    const already = allTeams.find(t => (t.members||[]).includes(currentUser.uid));
    if(already){ modalMsg.style.color='#f6a6a6'; modalMsg.textContent = 'You are already in a team.'; return;
    }
    if(allTeams.length >= MAX_TEAMS){ modalMsg.style.color='#f6a6a6'; modalMsg.textContent = 'Team cap reached.'; return; }
    modalCreateBtn.disabled = true; modalCreateBtn.textContent = 'Creating...';
    try{
      await addDoc(collection(db,'teams'), {
        name,
        captainUid: currentUser.uid,
        ownerUid: currentUser.uid,
        members: [ currentUser.uid ],
        color,
        createdAt: new Date()
      });
      closeModal();
    } catch(e){
      console.error('create team err', e);
      modalMsg.style.color = '#f6a6a6';
      modalMsg.textContent = 'Failed to create (permissions?).';
    } finally {
      modalCreateBtn.disabled = false; modalCreateBtn.textContent = 'Create';
    }
  };

  onAuthStateChanged(auth, (user)=>{
    currentUser = user;
    if(user){
      profileLoggedOut.style.display='none';
      profileCard.style.display='block';
      startUserListener(user.uid);
      const navLogin = document.getElementById('navLogin');
      if(navLogin){ navLogin.textContent='Logout'; navLogin.onclick = async ()=>{ if(!confirm('Logout?')) return; try{ await signOut(auth); }catch(e){console.error(e);} }; }
    } else {
      showLoggedOut();
      currentUserDoc = null;
      populateMiniValues();
      const navLogin = document.getElementById('navLogin');
      if(navLogin){ navLogin.textContent='Login'; navLogin.onclick = ()=> window.location.href='login.html'; }
    }
    updateCreateButtonState();

    // New: check admin status and show admin link (preferred via claims, fallback to users doc)
    (async ()=>{
      try {
        if(!user){
          currentUserIsAdmin = false;
          applyAdminUI();
          if(navAdmin) navAdmin.style.display = 'none';
          return;
        }
        // preferred: check custom claims
        let claimsOk = false;
        try {
          const idRes = await user.getIdTokenResult();
          const claims = idRes.claims || {};
          if(claims.admin || claims.isAdmin || claims.superAdmin || claims.isSuperAdmin) claimsOk = true;
        } catch(e){ console.warn('getIdTokenResult failed when checking claims:', e); }

        if(!claimsOk){
          // fallback: read users/{uid}
          try {
            const udoc = await getDoc(doc(db,'users', user.uid));
            const data = udoc.exists() ? udoc.data() : {};
            if(data.isAdmin || data.isSuperAdmin) claimsOk = true;
          } catch(e){ console.warn('fallback user doc admin check failed:', e); }
        }

        currentUserIsAdmin = !!claimsOk;
        applyAdminUI();

        if(claimsOk){
          if(navAdmin){
            navAdmin.style.display = 'inline-block';
            navAdmin.onclick = ()=> { window.location.href = 'admin.html'; };
          }
        } else {
          if(navAdmin) navAdmin.style.display = 'none';
        }
      } catch(e){
        console.error('admin button check failed', e);
        currentUserIsAdmin = false;
        applyAdminUI();
        if(navAdmin) navAdmin.style.display = 'none';
      }
    })();
  });

  function startUserListener(uid){
    const userRef = doc(db, 'users', uid);
    try {
      onSnapshot(userRef, (snap) => {
        currentUserDoc = snap.exists ? snap.data() : null;

        // If users doc explicitly marks isAdmin, reflect that (keeps UI consistent)
        if(currentUserDoc && (currentUserDoc.isAdmin || currentUserDoc.isSuperAdmin)){
          currentUserIsAdmin = true;
        }
        populateMiniValues(); showProfileCard(); updateCreateButtonState(); updateTeamBadge();
        applyAdminUI();
      }, err => console.error('user doc err', err));
    } catch(e){ console.error('startUserListener', e); }
  }

  // --- Perform Firestore cleanup: remove user from teams and delete user doc ---
  async function performClientDelete(uid){
    try {
      const myTeams = (allTeams || []).filter(t => (t.members || []).includes(uid));
      for(const t of myTeams){
        const members = t.members || [];
        const isCaptain = t.captainUid === uid;
        if(isCaptain && members.length <= 1){
          // delete team if sole member and captain
          try { await deleteDoc(doc(db,'teams',t.id)); } catch(e){ console.warn('failed to delete team', t.id, e); }
        } else {
          // remove from members if not sole captain
          try { await updateDoc(doc(db,'teams',t.id), { members: arrayRemove(uid) }); } catch(e){ console.warn('failed to remove member from team', t.id, e); }
        }
      }

      // Delete user's Firestore profile doc
      try { await deleteDoc(doc(db,'users', uid)); } catch(e){ console.warn('failed to delete user doc', e); }
      return { success: true };
    } catch(err){
      console.error('performClientDelete err', err);
      return { success: false, error: err };
    }
  }

  // --- Modal helpers for reauth ---
  function openReauthModal(){
    const m = document.getElementById('reauthModal'); if(!m) return;
    m.setAttribute('aria-hidden','false'); m.classList.add('open');
    const pw = document.getElementById('reauthPassword'); if(pw){ pw.value=''; pw.focus(); }
    const msg = document.getElementById('reauthMsg'); if(msg) msg.textContent = '';
  }
  function closeReauthModal(){
    const m = document.getElementById('reauthModal'); if(!m) return;
    m.setAttribute('aria-hidden','true'); m.classList.remove('open');
  }

  // --- Reauth + delete flow ---
  async function promptForPasswordAndDelete(){
    if(!currentUser) { alert('You must be logged in to delete your account.'); return; }

    openReauthModal();

    const confirmBtn = document.getElementById('reauthConfirmBtn');
    const cancelBtn  = document.getElementById('reauthCancelBtn');
    const pwInput    = document.getElementById('reauthPassword');
    const msgEl      = document.getElementById('reauthMsg');

    if(!confirmBtn || !cancelBtn || !pwInput) { alert('Reauth UI missing'); return; }

    function cleanup(){
      confirmBtn.onclick = null;
      cancelBtn.onclick = null;
    }

    cancelBtn.onclick = () => { cleanup(); closeReauthModal(); };

    confirmBtn.onclick = async () => {
      msgEl.style.color = '#bfe8c6'; msgEl.textContent = 'Verifying password...';
      confirmBtn.disabled = true;

      const password = pwInput.value || '';
      if(!password){
        msgEl.style.color = '#f6a6a6'; msgEl.textContent = 'Please enter your password.';
        confirmBtn.disabled = false;
        return;
      }

      try {
        const email = currentUser.email;
        if(!email) throw new Error('No email associated with this account.');

        const credential = EmailAuthProvider.credential(email, password);

        // Reauthenticate (refreshes recent sign-in)
        await reauthenticateWithCredential(currentUser, credential);

        // Now perform Firestore cleanup BEFORE deleting Auth user
        msgEl.textContent = 'Cleaning up Firestore...';
        const res = await performClientDelete(currentUser.uid);
        if(!res.success){
          msgEl.style.color = '#f6a6a6';
          msgEl.textContent = 'Failed to clean up Firestore. See console.';
          confirmBtn.disabled = false;
          return;
        }

        // Delete the Auth account (should succeed because we just reauth'd)
        try {
          await deleteUser(currentUser);
        } catch (delAuthErr) {
          console.error('deleteUser failed after reauth', delAuthErr);
          msgEl.style.color = '#f6a6a6';
          msgEl.textContent = 'Could not delete Auth account directly. Please sign in again and try or contact support.';
          confirmBtn.disabled = false;
          return;
        }

        // final sign-out + redirect
        try { await signOut(auth); } catch(e){ /* ignore */ }
        cleanup(); closeReauthModal();
        alert('Account deleted. Redirecting home.');
        window.location.href = '/code-clash/';

      } catch(err){
        console.error('reauth or delete error', err);
        const code = err?.code || '';
        if(code === 'auth/wrong-password' || code === 'auth/invalid-credential'){
          msgEl.style.color = '#f6a6a6';
          msgEl.textContent = 'Wrong password. Try again.';
        } else if(code === 'auth/multi-factor-auth-required'){
          msgEl.style.color = '#f6a6a6';
          msgEl.textContent = 'This account requires multi-factor authentication. Please re-login to complete verification or contact support.';
        } else {
          msgEl.style.color = '#f6a6a6';
          msgEl.textContent = err?.message || 'Reauthentication failed.';
        }
        confirmBtn.disabled = false;
      }
    };
  }

  // Wire delete button to reauth flow
  deleteAccountBtn.addEventListener('click', async () => {
    if(!currentUser) { alert('You must be logged in to delete your account.'); return; }
    if(!confirm('Delete your account? This is permanent and will remove your profile and remove you from any teams.')) return;
    // open password prompt and run reauth+delete
    promptForPasswordAndDelete();
  });

  // ensure UI starts in a consistent state
  showAllMiniValues();
  showLoggedOut();

})();
</script>
</body>
</html>
